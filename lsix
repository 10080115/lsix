#!/bin/bash

# lsix: like ls, but for images.
# Shows thumbnails of images with titles directly in terminal. 

# Requirements: just ImageMagick (and a Sixel terminal, of course)

# Version 1.6
# B9 February 2018

# See end of file for USAGE.


# The following defaults may be overridden if autodetection succeeds.
numcolors=16     # Default number of colors in the palette.
background=white # Default montage background.
foreground=black # Default text color.
width=800	 # Default width of screen in pixels.

tilesize=120	 # Width and height of each tile in the montage.
tilewidth=$tilesize
tileheight=$tilesize

# Sanity check and compatibility
if [[ ${BASH_VERSINFO[0]} -gt 3 ]]; then
    timeout=0.1			# How long to wait for terminal to respond.
else
    timeout=1			# Bash 3's `read` could not handle decimals.
fi

if ! command -v montage >/dev/null; then
    echo "Please install ImageMagick" >&2
    exit 1
fi

cleanup() {
    echo -n $'\e\\'		# Escape sequence to stop SIXEL.
    stty echo			# Reset terminal to show characters.
    exit 0
}
trap cleanup SIGINT SIGHUP SIGABRT EXIT



# shortlabel() and nibble() exist simply to make filenames shorter.
# They replace common prefixes and suffixes with ellipses.
#
# This is needed since Montage just splats long filenames on top of
# each other. However, it is perilous, as we are dealing with
# arbitrary input in a shell script. Dealing with strange characters,
# unicode, and spaces is not something a shell script should have to
# do. "

previousname=""
shortlabel() {
    # Take a list of filenames and shorten them if they look like the
    # previous filenames by removing prefixes and suffixes.
    # Output as 'montage' arguments.
    # E.g.: -label "foo" "qwertyfooyuiop.png" -label "bar" qwertybaryuiop.png"

    # every arg in "$@" is a filename like "nm-stage02-connecting-tile-001.png"
    for arg; do
        echo -n "-label '"
        # Remove matching {pre,suf}fix and print result
        echo -n $(nibble "$previousname" "$arg")
        echo -n "' "
        echo "$arg"             # Filename for montage to show
        previousname="$arg"
    done
}

previ=0
prevj=0
nibble() {
    # Given two strings a & b (previous and current filename),
    # return the second string after removing identical prefixes and suffixes.

    # Prefix replacement is only done if at least five characters are saved.
    # (Room for ellipses and also prevents adding ellipses for extensions).
    # Extensions (e.g., ".jpg") are removed without ellipses.
    
    # Example: "qwertyasdffred.png" "qwertyasdfjuki.png" -> "...juki.png"
    # Example: "qwertyfredabc.png" "qwertyjukiabc.png" -> "...juki..."
    # Example: "abcfred.png" "abcjuki.png" -> "abcjuki.png"  
    # Example: "qwerty1.png" "qwerty.png" -> "qwerty.png"  
    a="$1"
    b="$2"

    # Short circuit: don't bother nibbling if the filenames are short enough.
    # On my setup, that's about 15 characters.
    if [[ ${#b} -le 15 ]]; then
        echo "$b"
        return
    fi

    # Find common prefix; at end of loop, first $i character match
    for (( i=0; i<${#a}; i++)); do
        if [[ ${a:i:1} != ${b:i:1} ]]; then
            break
        fi
    done
#    echo "Debug: i: $i, $previ" >&2

    # If tail of prefix match are digits, treat them specially, so we
    # get more context. (E.g., 237, 238, 239, 240; not 7, 8, 9, 40)
    if [[ ${b:i:1} =~ [0-9] ]]; then
        for t in once twice; do
            if [[ ${b:i-1:1} =~ [0-9] ]]; then
                i=$((i-1))
            fi
        done
    fi

    # Shorten if match is at least 5 and the match hasn't gotten shorter
    if [[ $i -ge 5  &&  $i -ge $previ ]]; then
        label="...${b:i}"
        previ=$i
    else
        label="$b"
        previ=0
    fi

    # At this point, $label is $b with any prefix removed and ellipses added.
    # Now find common suffix; at end of loop, last $j characters match
    for (( j=1; j<=${#a}; j++)); do
        if [[ ${a: -j:1} != ${label: -j:1} ]]; then
            break
        fi
    done
    j=$((j-1))
#    echo "Debug j: $j, $prevj" >&2

    # Shorten if match is at least 5 and the match hasn't gotten shorter
    if [[ $j -ge 5  &&  $j -ge $prevj ]]; then
        label="${label:0: -j}..."
        prevj=$j
    elif [[ ${label: -j:1} == "." ]]; then
        # ellide filename extensions, but don't show ellipsis
        label="${label:0: -j}"
        prevj=$j
    else
        # label does not change.
        prevj=0
    fi

    # After removing prefix and suffix is filename still too long?
    if [[ ${#label} -gt 15 ]]; then
        # Okay, throw in a gratuitous newline. 
        midpoint=$(( ${#label} / 2 ))
        label=${label:0:midpoint}$"\n"${label:midpoint}
    fi

    # Return the unique part of $b
    echo "$label"
}


# Don't show escape sequences the terminal doesn't understand.
stty -echo			# Hush-a Mandara Ni Pari

# TERMINAL COLOR AUTODETECTION.
# Find out how many color registers the terminal has
IFS=";"  read -a REPLY -s -t ${timeout} -d "S" -p $'\e[?1;1;0S' >&2
[[ ${REPLY[1]} == "0" ]] && numcolors=${REPLY[2]}

# Increase colors, if needed
if [[ $numcolors -lt 256 ]]; then
    # Attempt to set the number of colors to 256.
    # This will work for xterm, but fail on a real vt340.
    IFS=";"  read -a REPLY -s -t ${timeout} -d "S" -p $'\e[?1;3;256S' >&2
    [[ ${REPLY[1]} == "0" ]] && numcolors=${REPLY[2]}
fi

# Query the terminal background and foreground colors.
IFS=";:/"  read -a REPLY -r -s -t ${timeout} -d "\\" -p $'\e]11;?\e\\' >&2
if [[ ${REPLY[1]} =~ ^rgb ]]; then
    # Return value format: $'\e]11;rgb:ffff/0000/ffff\e\\'.
    # ImageMagick wants colors formatted as #ffff0000ffff.
    background='#'${REPLY[2]}${REPLY[3]}${REPLY[4]%%$'\e'*}
    IFS=";:/"  read -a REPLY -r -s -t ${timeout} -d "\\" -p $'\e]10;?\e\\' >&2
    if [[ ${REPLY[1]} =~ ^rgb ]]; then
	foreground='#'${REPLY[2]}${REPLY[3]}${REPLY[4]%%$'\e'*}
	# Check for "Reverse Video".
	IFS=";?$"  read -a REPLY -s -t ${timeout} -d "y" -p $'\e[?5$p'
	if [[ ${REPLY[2]} == 1 || ${REPLY[2]} == 3 ]]; then
	    temp=$foreground
	    foreground=$background
	    background=$temp
	fi
    fi
fi

# Try dtterm WindowOps to find out the window size.
IFS=";" read -a REPLY -s -t ${timeout} -d "t" -p $'\e[14t' >&2
if [[ $? == 0  &&  ${REPLY[2]} -gt 0 ]]; then
    width=${REPLY[2]}
fi

# BUG WORKAROUND: XTerm cannot show images wider than 1000px.
# Remove this hack once XTerm gets fixed. Last checked: XTerm(327)
if [[ $width -ge 1000 ]]; then  width=1000; fi

# Space between tiles is about 0.5% of total screen width
tilexspace=$((width/200))
tileyspace=$((tilexspace/2))
# Figure out how many tiles we can fit per row.
numtiles=$((width/(tilewidth + 2*tilexspace)))


if [[ $# == 0 ]]; then
    # No command line args? Use a sorted list of image files in CWD.
   shopt -s nullglob nocaseglob nocasematch
   set - *{jpg,jpeg,png,gif,tiff,tif,p?m,x[pb]m,bmp,ico,svg,eps}
   [[ $# != 0 ]] || exit
   mapfile -t < <(printf "%s\n" "$@" | sort) 

   # Only show first frame of animated GIFs if filename not specified.
   for x in ${!MAPFILE[@]}; do
       if [[ ${MAPFILE[$x]} =~ gif$ ]]; then
	   MAPFILE[$x]+="[0]"
       fi
   done
   set - "${MAPFILE[@]}"
fi

imoptions="-tile ${numtiles}x1" # Each montage image is 1 row, $numtiles columns
imoptions+=" -geometry ${tilewidth}x${tileheight}>+${tilexspace}+${tileyspace}" # Size of each tile and spacing
imoptions+=" -label %f"		# Put a label underneath each tile
imoptions+=" -background $background -fill $foreground" # Use terminal's colors
imoptions+=" -auto-orient"	# Properly rotate JPEGs from cameras
if [[ $numcolors -gt 16 ]]; then
    imoptions+=" -shadow"		# Just for fun :-)
fi

if [[ $# -le 21 ]]; then 
    # Only a few pictures to show, do it in one (multipage) chunk.
    montage $imoptions $(shortlabel "$@") gif:- \
	| convert - -colors $numcolors sixel:-
else
    # Lots of pictures, so show them a row at a time instead
    # of taking a long time to make one huge montage.
    while [ $# -gt 0 ]; do
	while [ $# -gt 0  -a  ${#onerow[@]} -lt $numtiles ]; do
	    len=${#onerow[@]}
	    onerow[$len]="$1"
	    shift
	done
	montage $imoptions $(shortlabel "${onerow[@]}") gif:-  \
	    | convert - -colors $numcolors sixel:-
	onerow=()
    done
fi    
    
# Send an escape sequence and wait for a response from the terminal
# so that the program won't quit until images have finished transferring.
read -s -t 60 -d "c" -p $'\e[c' >&2


######################################################################
# NOTES:

# Usage: lsix [ FILES ... ] 

# * FILES can be any image file that ImageMagick can handle.
#
# * If no FILES are specified the most common file extensions are tried.
#   (For now, lsix only searches the current working directory.)
#
# * Non-bitmap graphics often work fine (.svg, .eps, .pdf, .xcf).
#
# * Files containing multiple images (e.g., animated GIFs) will show
#   all the images if the filename is specified at the command line.
#   Only the first frame will be shown if "lsix" is called with no
#   arguments.
#
# * Because this uses escape sequences, it works seamlessly through ssh.
#
# * If your terminal supports reporting the background and foreground
#   color, lsix will use those for the montage background and text fill.
#
# * If your terminal supports changing the number of color registers
#   to improve the picture quality, lsix will do so.

# * Only software needed is ImageMagick (e.g., apt-get install imagemagick).

# Your terminal must support SIXEL graphics. E.g.,
#
#     xterm -ti vt340

# * To make vt340 be the default xterm type, set this in .Xresources:
#
#     ! Allow sixel graphics. (Try: "convert -colors 16 foo.jpg sixel:-").
#     xterm*decTerminalID	:	vt340

# * Xterm does not support reporting the screen size in pixels unless
#   you add this to your .Xresources:
#
#     ! Allow xterm to read the terminal window size (op #14)
#     xterm*allowWindowOps      : False
#     xterm*disallowedWindowOps : 1,2,3,4,5,6,7,8,9,11,13,18,19,20,21,GetSelection,SetSelection,SetWinLines,SetXprop

# * Be cautious using lsix on videos (lsix *.avi) as ImageMagick will
#   try to make a montage of every single frame and likely exhaust
#   your memory and/or your patience.

# BUGS

# * Directories are not handled nicely.
# * ImageMagick's Montage doesn't handle long filenames nicely.
# * Some transparent images (many .eps files) presume a white background
#   and will not show up if your terminal's background is black. 
# * This file is getting awfully long for a one line kludge. :-)

# LICENSE INFORMATION
# (AKA, You know your kludge has gotten out of hand when...)

# Dual license:
# * You have all the freedoms permitted to you under the
#   GNU GPL >=3. (See the included LICENSE file).

# * Additionally, this program can be used under the terms of whatever
#   license 'xterm' is using (now or in the future). This is primarily
#   so that, if the xterm maintainer (currently Thomas E. Dickey) so
#   wishes, this program may be included with xterm as a Sixel test.
#   However, anyone who wishes to take advantage of this is free to do so.
